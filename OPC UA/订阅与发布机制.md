# MonitoredItem

每个监控项均指明了要监控的项目（item）和用来发送通知的订阅。

item可以是一个节点的属性（node attribute）。
（此次有图片）
![订阅与发布](C:%5CUsers%5CAdmin%5CPictures%5C%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83.png)
-   MonitorItem可以监控一个属性，一个变量或者一个事件
-   可以通过MonitorItem定义的过滤器（fiter)，来决定是否产生一个通知
-   Queue attribute定义了可以被缓存的通知数量，可以通过配置策略决定丢弃新消息还是最老的消息
- # Subscription

订阅用来向客户端报告通知，其行为可以被总结如下：

-   订阅包含一组由客户端分配的监控项。监控项可以生成通知，这些通知，由订阅发送给客户端
-   订阅拥有一个发布间隔，订阅的发布间隔定义了订阅执行的循环率。每次执行，订阅均试图发送一条NotificationMessages，NotificationMessages中包含了还没有报告给客户端的通知
-   订阅以回应发布请求的方式向客户端发送NotificationMessages。发布请求通常以接收顺序存储到Session中，当有通知需要发送时，在每次发布循环时，会从队列中取出相应的请求，并发送通知到客户端，如果没有待发送通知，请求则不会从队列中被删除
-   在循环的开始，如果已经存在待发送通知但还没有发布请求，服务器将会进入等待状态，一旦接收到发布请求，则立即向客户端发送通知，无需等待另外一次循环
-   订阅有一个存活计数器，保存了没有发送通知的周期循环次数，当循环次数达到用户在创建订阅时配置的预置，则会发送一条存活消息到客户端，同时从队列中取出一条发布请求，用于表示该订阅仍然处于存活状态。存活NotificationMessage中不包含通知，但包含下一条消息的序列号
-   订阅是否发布通知可以由客户端在创建时指定，也可以后续通过SetPublishMode服务设置，设置为Fasle时，订阅将停止向客户端推送通知，但是订阅会继续执行，且持续发送存活消息
-   订阅包含一个寿命计数器，保存了在没有发布请求时经历的循环次数，当达到阈值时，会删除这个订阅以及与订阅相关的监控项。在删除订阅时，会发送一条StateChangeNotification消息，并携带状态码Bad_Timeout
-   Session维护了已发送通知的转发队列，只有当客户端确认消息接收后，才会从队列宗移除，服务器应当保存有两倍于发送请求数量的消息，这种能力可以由服务器的profile定义，如果转发队列满，则删除最旧的消息。当订阅被转移到另外的session时，转发队列同时也需要迁移过去

序列号是一个UINT32，并从1开始向前滚动。

当订阅创建后，在第一个周期结束时，会向client发送一条消息，用于通知客户端订阅可用。如果有通知要发送，则发送NotificationMessage，如果没有，则发送存活消息，并设置序列号为1，这是唯一不需要等待到keep alive阈值的场景。

客户端接受消息要比发布周期更加频繁，因一个发布周期可能包含有多条消息，但客户端可以设置服务器不缓存发布通知来减轻压力，但会增加响应的延时。

在订阅的声明周期中，序列号不会被重置，也即在40亿消息中不会出现重复的消息ID。

消息序列号还可以用于消息重发。

订阅被设计为独立于具体的通信协议，短暂的连接丢失不会导致丢失数据和事件。在设计时，要确保该特性得以正确实现，也即能够处理较长时间的通讯中断和有计划断链。如果服务器支持该特性，服务器的缓存区将会设计的比较大。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTI5NzQxMDM3NV19
-->